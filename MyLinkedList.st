Object subclass: #MyLinkedList	instanceVariableNames: 'head tail'	classVariableNames: ''	package: 'MyLinkedList'!!MyLinkedList commentStamp: 'idtalebreda 2/2/2021 17:53' prior: 0!I am MyLinkedList, and i represent a double linked list.A linked list is a recursive structure, containing a head and a tail.- how to create instances, in a playground execute the following instructions:	| list node1 node2 node3 |	node1 := Node new.	node1 setValue: 2.	node2 := Node new.	node2 setValue: 5.	node3 := Node new.	node3 setValue: 4.	list := MyLinkedList new.	list addInLast: node1.	list addInLast: node2.	list addInLast: node3.	list!!MyLinkedList methodsFor: 'printing' stamp: 'idtalebreda 1/31/2021 19:50'!printOn: aStream	"Append ance of characters to aStream that identify the receiver."	aStream		nextPutAll: 'LinkedList -> head: ';		print: head.	aStream		nextPutAll: ', tail: ';		print: tail.! !!MyLinkedList methodsFor: 'testing-empty' stamp: 'idtalebreda 1/31/2021 18:11'!isEmpty	^ head isNil! !!MyLinkedList methodsFor: 'initialization' stamp: 'idtalebreda 1/31/2021 20:55'!initialize 	super initialize ! !!MyLinkedList methodsFor: 'adding' stamp: 'idtalebreda 2/1/2021 00:12'!addInFirst: element	"Add the element at the head of the linked list	 and return the element added 	"	element setNextValue: head .	tail ifNil: [ tail := element ].	head ifNotNil: [head setPreviousValue: element].	head := element.	^ element! !!MyLinkedList methodsFor: 'adding' stamp: 'idtalebreda 1/31/2021 23:41'!addInLast: element 	"Add the element at the tail of the linked list	return the element added 	"		head ifNil: [ head := element ].	tail ifNotNil: [ tail setNextValue: element ].	element setPreviousValue: tail.	tail := element.	^ element		! !!MyLinkedList methodsFor: 'removing' stamp: 'idtalebreda 2/2/2021 17:42'!removeLastElement	"remove the last element(the tail) of a linked list	 Complexity order: O(1)	"	| node |	(self isEmpty) ifTrue: [ NotFound  signalFor: self].	node := tail.	tail := tail getPreviousValue.	tail setNextValue: nil.	^ node! !!MyLinkedList methodsFor: 'removing' stamp: 'idtalebreda 2/2/2021 17:42'!removeFirstElement	"remove the first element of a linked list(the element in the head)	 Complexity order: O(1)	"	| node |	(self isEmpty) ifTrue: [ NotFound  signalFor: self ].	node := head.	head := head getNextValue.	head setPreviousValue: nil.	^ node! !!MyLinkedList methodsFor: 'accessing' stamp: 'idtalebreda 1/31/2021 18:30'!tail	^ tail! !!MyLinkedList methodsFor: 'accessing' stamp: 'idtalebreda 1/31/2021 18:30'!tail: anObject	tail := anObject! !!MyLinkedList methodsFor: 'accessing' stamp: 'idtalebreda 1/31/2021 18:30'!head	^ head! !!MyLinkedList methodsFor: 'accessing' stamp: 'idtalebreda 1/31/2021 18:30'!head: anObject	head := anObject! !!MyLinkedList methodsFor: 'method' stamp: 'idtalebreda 2/2/2021 17:47'!getElementAt: index	"retrieves the element at the specified index	 if the index is greater than the size of the list, we return a -1 as an error 	"	| j node |	j := 1.		self isEmpty		ifTrue: [ CollectionIsEmpty signalWith: self ].	index > self size		ifTrue: [ NotFound signalFor: self ].			node := head.	[ j < index ]		whileTrue: [ j := j + 1.			node := node getNextValue ].	^ node	! !!MyLinkedList methodsFor: 'method' stamp: 'idtalebreda 2/1/2021 00:44'!size	"calculate the size of the linked list.	 Complexity order: O(n) wich n is the lentgh of the linked list	"	| cmp next |	next := head.	cmp := 0.	head ifNil: [ ^ cmp ].	[ next notNil ]		whileTrue: [ cmp := cmp + 1.			          next:= next getNextValue 			        ].	^ cmp		! !Object subclass: #Node	instanceVariableNames: 'value nextValue previousValue'	classVariableNames: ''	package: 'MyLinkedList'!!Node commentStamp: 'idtalebreda 2/2/2021 17:54' prior: 0!I am Node, and i represent a node (or a link) of a linkedListA node in a linked list is a cell containing a value and a pointer to the next node.The class defines two instance variables in order to represent a cell as described above, the first variable represents the value of the node and the second variable defines a pointer to the next node.- how to create instances.	| node |   node := Node new. 	node setValue 1.	node setNextValue 2	Internal Representation and Key Implementation Points.    Instance Variables	nextValue:		<Object>	value:		<Object>!!Node methodsFor: 'initializing' stamp: 'idtalebreda 1/31/2021 17:34'!initialize	super initialize! !!Node methodsFor: 'accessing' stamp: 'idtalebreda 1/31/2021 21:49'!getPreviousValue	^ previousValue! !!Node methodsFor: 'accessing' stamp: 'idtalebreda 1/31/2021 21:49'!setPreviousValue: anObject	previousValue := anObject! !!Node methodsFor: 'accessing' stamp: 'idtalebreda 1/31/2021 17:50'!setValue: newValue	value := newValue! !!Node methodsFor: 'accessing' stamp: 'idtalebreda 1/31/2021 17:52'!getNextValue	^nextValue! !!Node methodsFor: 'accessing' stamp: 'idtalebreda 1/31/2021 17:46'!getValue	^ value! !!Node methodsFor: 'accessing' stamp: 'idtalebreda 1/31/2021 17:52'!setNextValue: newNextValue	nextValue := newNextValue! !!Node methodsFor: 'printing' stamp: 'idtalebreda 1/31/2021 21:51'!printOn: aStream	"Append a sequence of characters to aStream that identify the receiver."	aStream		nextPutAll: '{value: ';		print: value.	aStream		nextPutAll: ', next: ';		print: nextValue.	aStream		nextPutAll: ', prev: ';		print: previousValue.		aStream		nextPutAll: '}'! !